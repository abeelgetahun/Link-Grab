import 'package:hive_flutter/hive_flutter.dart';
import '../models/link.dart';
import '../models/group.dart';
import '../models/settings.dart';

// --- SettingsService ---
class SettingsService {
  static const String _boxName = 'settingsBox';

  Future<Box<Settings>> _getBox() async {
    // This check is to prevent errors if the box is accessed before being opened in main.dart
    // In a real scenario, main.dart would ensure boxes are open.
    if (!Hive.isBoxOpen(_boxName)) {
      // Attempt to open, though ideally this is done at app startup
      try {
        return await Hive.openBox<Settings>(_boxName);
      } catch (e) {
        print("Error opening settingsBox in service: $e");
        rethrow; // Or handle more gracefully
      }
    }
    return Hive.box<Settings>(_boxName);
  }

  Future<Settings> getSettings() async {
    final box = await _getBox();
    // Assuming a single settings object, stored with a known key, e.g., 'default'
    final settings = box.get('default');
    if (settings == null) {
      final defaultSettings = Settings(darkMode: false);
      await box.put('default', defaultSettings);
      return defaultSettings;
    }
    return settings;
  }

  Future<void> saveSettings(Settings settings) async {
    final box = await _getBox();
    await box.put('default', settings);
  }
}

// --- GroupService ---
class GroupService {
  static const String _boxName = 'groupsBox';
  static const String _linksBoxName = 'linksBox';


  Future<Box<Group>> _getGroupBox() async {
    if (!Hive.isBoxOpen(_boxName)) {
      try {
        return await Hive.openBox<Group>(_boxName);
      } catch (e) {
        print("Error opening groupsBox in service: $e");
        rethrow;
      }
    }
    return Hive.box<Group>(_boxName);
  }

  Future<Box<Link>> _getLinkBox() async {
    if (!Hive.isBoxOpen(_linksBoxName)) {
      try {
        return await Hive.openBox<Link>(_linksBoxName);
      } catch (e) {
        print("Error opening linksBox in GroupService: $e");
        rethrow;
      }
    }
    return Hive.box<Link>(_linksBoxName);
  }

  Future<void> addGroup(Group group) async {
    final box = await _getGroupBox();
    // Enforce unique group names (Hive keys are unique by default if using name as key)
    // Or, if using auto-incrementing IDs, you'd query first.
    // For this MVP, let's assume group.name is used as the key for simplicity,
    // or that models will use UUIDs generated before calling add.
    // If group.name is the key:
    if (box.containsKey(group.name)) {
      throw Exception('Group with name "${group.name}" already exists.');
    }
    await box.put(group.name, group); // Using name as key
  }

  Future<List<Group>> getAllGroups() async {
    final box = await _getGroupBox();
    return box.values.toList();
  }

  Future<void> deleteGroup(String groupName) async {
    final groupBox = await _getGroupBox();
    await groupBox.delete(groupName);

    // Update links associated with this group
    final linkBox = await _getLinkBox();
    final List<Link> linksToUpdate = [];
    for (var link in linkBox.values) {
        if (link.group == groupName) {
            // Create a new link instance with group set to null
            linksToUpdate.add(Link(
                id: link.id,
                url: link.url,
                title: link.title,
                description: link.description,
                isFavorite: link.isFavorite,
                createdAt: link.createdAt,
                group: null, // Set group to null
            ));
        }
    }
    // Update modified links
    for (var updatedLink in linksToUpdate) {
        await linkBox.put(updatedLink.id, updatedLink);
    }
  }
   Future<Group?> getGroupByName(String name) async {
    final box = await _getGroupBox();
    return box.get(name);
  }
}

// --- LinkService ---
class LinkService {
  static const String _boxName = 'linksBox';

  Future<Box<Link>> _getBox() async {
    if (!Hive.isBoxOpen(_boxName)) {
      try {
        return await Hive.openBox<Link>(_boxName);
      } catch (e) {
        print("Error opening linksBox in service: $e");
        rethrow;
      }
    }
    return Hive.box<Link>(_boxName);
  }

  Future<void> addLink(Link link) async {
    final box = await _getBox();
    // Assuming link.id is unique (e.g., UUID generated by model or before calling)
    await box.put(link.id, link);
  }

  Future<List<Link>> getAllLinks() async {
    final box = await _getBox();
    return box.values.toList();
  }

  Future<List<Link>> getLinksByGroup(String groupName) async {
    final box = await _getBox();
    return box.values.where((link) => link.group == groupName).toList();
  }

  Future<List<Link>> getFavoriteLinks() async {
    final box = await _getBox();
    return box.values.where((link) => link.isFavorite).toList();
  }

  Future<List<Link>> getRecentLinks({int count = 20}) async {
    final box = await _getBox();
    var links = box.values.toList();
    links.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    return links.take(count).toList();
  }

  Future<void> updateLink(Link link) async {
    final box = await _getBox();
    await box.put(link.id, link); // Assumes link.id exists and is the key
  }

  Future<void> deleteLink(String linkId) async {
    final box = await _getBox();
    await box.delete(linkId);
  }
   Future<Link?> getLinkById(String id) async {
    final box = await _getBox();
    return box.get(id);
  }
}
